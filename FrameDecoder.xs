#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include <libavformat/avformat.h>
#include <libswscale/swscale.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#pragma mark types
typedef struct AVFormatContext FD_AVFormatCtx;
typedef struct AVCodecContext  FD_AVCodecCtx;
typedef struct AVFrame         FD_AVFrame;
typedef short bool_t;
typedef uint8_t                FD_FrameBuffer;

#pragma mark globals
pthread_mutex_t AVFormatCtxMP;

MODULE = Video::FFmpeg::FrameDecoder		PACKAGE = Video::FFmpeg::FrameDecoder
PROTOTYPES: ENABLE

#pragma mark boot
BOOT:
{
    av_register_all();
    pthread_mutex_init(&AVFormatCtxMP, NULL);
}

#pragma mark methods

FD_AVFormatCtx*
ffv_fd_open_uri(uri)
char* uri;
    CODE:
    {
        /* ffv_fd_open_uri: wrapper around av_open_input_file */

        int lock_status;

        /* use a mutex protect opening a file. I assume this is
         reqiuired because Video::FFmpeg does it */

        lock_status = pthread_mutex_lock(&AVFormatCtxMP);
        if ( lock_status != 0 ) {
            croak("Unable to lock mutex AVFormatCtxMP for %s: %s", uri, sys_errlist[lock_status]);
        };

        FD_AVFormatCtx *formatCtx;

        if ( av_open_input_file(&formatCtx, uri, NULL, 0, NULL) != 0 ) {
            RETVAL = NULL;
            return;
        } else {
            RETVAL = formatCtx;
        }

        /* make sure we can read the stream */
        if ( av_find_stream_info(formatCtx) < 0 ) {
            RETVAL = NULL;
            return;
        }

        /* unlock mutex */
        lock_status = pthread_mutex_unlock(&AVFormatCtxMP);
        if ( lock_status != 0 ) {
            croak("Unable to unlock mutex AVFormatCtxMP for %s: %s", uri, sys_errlist[lock_status]);
        };
    }
    OUTPUT: RETVAL

unsigned int
ffv_fd_find_first_video_stream_index(ctx)
FD_AVFormatCtx* ctx;
    CODE:
    {
        /* given a context, look for the first video stream inside of
         it. returns stream index or -1 */
         

        int video_stream = -1;
        int i;

        for ( i = 0; i < ctx->nb_streams; i++ ) {
            if ( ctx->streams[i]->codec->codec_type==CODEC_TYPE_VIDEO ) {
                video_stream = i;
                break;
            }
        }
        
        RETVAL = video_stream;
    }
    OUTPUT: RETVAL

FD_AVCodecCtx*
ffv_fd_get_stream(ctx, idx)
int idx;
FD_AVFormatCtx* ctx;
    CODE:
    {
        /* get a stream from a format context by index.
        returns a pointer to the stream codec context or NULL */
        
        /* look up codec object */
        FD_AVCodecCtx *codec_ctx = ctx->streams[idx]->codec;
        RETVAL = codec_ctx;
    }
    OUTPUT: RETVAL

FD_AVFrame*
ffv_fd_alloc_frame()
    CODE:
    {
        /* allocate space for an AVFrame struct */
        RETVAL = avcodec_alloc_frame();
    }
    OUTPUT: RETVAL

void
ffv_fd_dealloc_frame(frame)
FD_AVFrame* frame;
    CODE:
    {
        /* dellocate frame storage */
        av_free(frame);
    }
    
void
ffv_fd_dealloc_frame_buffer(buf)
FD_FrameBuffer* buf;
    CODE:
    {
        /* dellocate frame buffer storage */
        free(buf);
    }

FD_FrameBuffer*
ffv_fd_alloc_frame_buffer(codec_ctx, dst_frame)
FD_AVCodecCtx* codec_ctx;
FD_AVFrame* dst_frame;
    CODE:
    {
        unsigned int size;
        FD_FrameBuffer *buf;
        
        /* calculate size of storage required for a RGB frame */
        size = avpicture_get_size(PIX_FMT_RGB24, codec_ctx->width,
            codec_ctx->height);
        
        /* allocate frame buffer storage */
        buf = malloc(size);
        
        /* assign appropriate parts of buffer to image planes in dst_frame */
        avpicture_fill((AVPicture *)dst_frame, buf, PIX_FMT_RGB24,
            codec_ctx->width, codec_ctx->height);
        
        RETVAL = buf;
    }
    OUTPUT: RETVAL


bool_t
ffv_fd_open_codec(codec_ctx)
FD_AVCodecCtx* codec_ctx;
    CODE:
    {
        /* ffv_fd_open_codec(codec_ctx) attempts to find a decoder for this
         codec and open it. returns success/failure */

        /* find the decoder for the video stream */
        AVCodec *codec = avcodec_find_decoder(codec_ctx->codec_id);
        if ( codec == NULL ) {
            /* could not find a decoder for this codec */
            RETVAL = 0;
            return;
        }

        /* open codec */
        if ( avcodec_open(codec_ctx, codec) < 0 ) {
            /* failed to open the codec */
            RETVAL = 0;
            return;
        }

        /* hack to correct wrong frame rates that seem to be generated by some codecs */
        if ( codec_ctx->time_base.num > 1000 && codec_ctx->time_base.den == 1 ) {
            codec_ctx->time_base.den = 1000;
        }

        RETVAL = 1;
    }
    OUTPUT: RETVAL

void
ffv_fd_close_codec(codec_ctx)
FD_AVCodecCtx* codec_ctx;
    CODE:
    {
        avcodec_close(codec_ctx);
    }

bool_t
ffv_fd_decode_frames(format_ctx, codec_ctx, stream_index, src_frame, dst_frame, dst_frame_buffer, frame_count, decoded_cb)
FD_AVFormatCtx* format_ctx;
FD_AVCodecCtx* codec_ctx;
unsigned int stream_index;
FD_AVFrame* src_frame;
FD_AVFrame* dst_frame;
FD_FrameBuffer* dst_frame_buffer;
unsigned int frame_count;
CV* decoded_cb;
    CODE:
    {
        AVPacket packet;
        unsigned int frameFinished, w, h;
        unsigned int frame = 0;
        struct SwsContext *img_convert_ctx = NULL;
        
        while( av_read_frame(format_ctx, &packet) >= 0 ) {
            if (packet.stream_index != stream_index)
                continue;
            
            avcodec_decode_video(codec_ctx, src_frame, &frameFinished, 
                packet.data, packet.size);

            if (! frameFinished) 
                continue;
                
            if (img_convert_ctx == NULL) {
                w = codec_ctx->width;
                h = codec_ctx->height;

                /* create context to convert to RGB24 */
                img_convert_ctx = sws_getContext(w, h, 
                				codec_ctx->pix_fmt, 
                				w, h, PIX_FMT_RGB24, SWS_BICUBIC,
                				NULL, NULL, NULL);

                if (img_convert_ctx == NULL) {
                    RETVAL = 0;
                	fprintf(stderr, "Cannot initialize the conversion context!\n");
                	av_free_packet(&packet);
                    return;
                }
			}
			
            sws_scale(img_convert_ctx, src_frame->data, src_frame->linesize, 0, 
                codec_ctx->height, dst_frame->data, dst_frame->linesize);
                
            /* we now have a decoded frame */
            if (++frame > frame_count)
                break;
            
            /* call perl CV callback */
        	dSP;
        	ENTER;
        	SAVETMPS;
        	PUSHMARK(SP);
        	XPUSHs( sv_2mortal( newSViv( frame )));
        	PUTBACK;

        	call_sv( decoded_cb, G_DISCARD );
	
        	FREETMPS;
        	LEAVE;
        }
        
        av_free_packet(&packet);
    }
    OUTPUT: RETVAL

void
ffv_fd_dump_format(ctx, title)
FD_AVFormatCtx* ctx;
char* title;
    CODE:
    {
        /* dumps information about the context to stderr */
        dump_format(ctx, 0, title, false);
    }

void
ffv_fd_destroy_context(ctx)
FD_AVFormatCtx* ctx;
    CODE:
    {
        /* destroy a context */
        av_close_input_file(ctx);
    }
